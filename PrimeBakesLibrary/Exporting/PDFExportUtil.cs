using NumericWordsConversion;

using PrimeBakesLibrary.Data.Accounts.Masters;
using PrimeBakesLibrary.Data.Common;

using Syncfusion.Drawing;
using Syncfusion.Pdf;
using Syncfusion.Pdf.Graphics;
using Syncfusion.Pdf.Grid;

namespace PrimeBakesLibrary.Exporting;

internal static class PDFExportUtil
{
	// Shared color constants
	internal static readonly Color _primaryColor = Color.FromArgb(226, 19, 123); // Changed to #e2137b
	internal static readonly Color _secondaryColor = Color.FromArgb(193, 14, 105); // Darker variant of primary
	internal static readonly Color _accentColor = Color.FromArgb(33, 150, 243); // Complementary blue
	internal static readonly Color _lightGray = Color.FromArgb(245, 245, 245);
	internal static readonly Color _darkGray = Color.FromArgb(64, 64, 64);

	// Shared font constants - Optimized font sizes for compact but readable layout
	internal static readonly PdfStandardFont _titleFont = new(PdfFontFamily.Helvetica, 16, PdfFontStyle.Bold); // Slightly increased for better readability
	internal static readonly PdfStandardFont _headerFont = new(PdfFontFamily.Helvetica, 10, PdfFontStyle.Bold); // Slightly increased for better readability  
	internal static readonly PdfStandardFont _subHeaderFont = new(PdfFontFamily.Helvetica, 9, PdfFontStyle.Bold); // Slightly increased for better readability
	internal static readonly PdfStandardFont _normalFont = new(PdfFontFamily.Helvetica, 8); // Slightly increased to prevent clipping
	internal static readonly PdfStandardFont _boldFont = new(PdfFontFamily.Helvetica, 8, PdfFontStyle.Bold); // Slightly increased to prevent clipping
	internal static readonly PdfStandardFont _smallFont = new(PdfFontFamily.Helvetica, 7); // Slightly increased for better readability

	internal const float _pageMargin = 10f; // Reduced from 15f for more space

	/// <summary>
	/// Creates a common PDF document header with customizable title
	/// </summary>
	internal static PdfPageTemplateElement CreateHeader(PdfDocument doc, string headerTitle)
	{
		var headerRect = new RectangleF(0, 0, doc.Pages[0].GetClientSize().Width, 40); // Reduced height for more compact layout

		PdfPageTemplateElement header = new(headerRect);
		header.Graphics.DrawRectangle(new PdfSolidBrush(_primaryColor), headerRect);

		// Main title
		PdfStringFormat titleFormat = new()
		{
			Alignment = PdfTextAlignment.Center,
			LineAlignment = PdfVerticalAlignment.Middle
		};

		header.Graphics.DrawString(headerTitle, _titleFont, PdfBrushes.White,
			new PointF(headerRect.Width / 2, headerRect.Height / 2 - 8), titleFormat);

		// Company tagline
		PdfStringFormat taglineFormat = new()
		{
			Alignment = PdfTextAlignment.Center,
			LineAlignment = PdfVerticalAlignment.Middle
		};

		var taglineFont = new PdfStandardFont(PdfFontFamily.Helvetica, 7, PdfFontStyle.Italic);
		header.Graphics.DrawString("Celebrating happiness", taglineFont, PdfBrushes.White,
			new PointF(headerRect.Width / 2, headerRect.Height / 2 + 12), taglineFormat);

		return header;
	}

	/// <summary>
	/// Creates a common PDF document footer with timestamp and pagination
	/// </summary>
	internal static PdfPageTemplateElement CreateFooter(PdfDocument doc)
	{
		RectangleF rect = new(0, 0, doc.Pages[0].GetClientSize().Width, 8); // Reduced from 10

		PdfPageTemplateElement footer = new(rect);
		PdfPageNumberField pageNumber = new(_smallFont, new PdfSolidBrush(_darkGray));
		PdfPageCountField count = new(_smallFont, new PdfSolidBrush(_darkGray));

		string prefix = "Generated By ";
		string suffix = $" | Page {{0}} of {{1}} | Printed on: {DateTime.Now:dddd, MMMM dd, yyyy hh:mm tt}";

		PdfCompositeField compositeField = new()
		{
			Text = prefix + "https://aadisoft.vercel.app" + suffix,
			AutomaticFields = [pageNumber, count],
			Font = _smallFont,
			Brush = new PdfSolidBrush(_darkGray),
			Bounds = footer.Bounds,
			StringFormat = new()
			{
				Alignment = PdfTextAlignment.Center,
				LineAlignment = PdfVerticalAlignment.Middle
			}
		};

		compositeField.Draw(footer.Graphics);
		return footer;
	}

	/// <summary>
	/// Draws common company information section
	/// </summary>
	internal static async Task<float> DrawCompanyInformation(PdfPage pdfPage, string invoiceType)
	{
		RectangleF detailsRect = new(15, 18, pdfPage.GetClientSize().Width - 30, 50); // Reduced height for more compact layout
		pdfPage.Graphics.DrawRectangle(new PdfPen(_lightGray, 1), new PdfSolidBrush(_lightGray), detailsRect);

		var mainLocation = await LedgerData.LoadLedgerByLocation(1);

		if (!string.IsNullOrEmpty(mainLocation.Alias))
			pdfPage.Graphics.DrawString(mainLocation.Alias, _normalFont, new PdfSolidBrush(_darkGray), new PointF(20, detailsRect.Y + 8)); // Reduced margin

		if (!string.IsNullOrEmpty(mainLocation.GSTNo))
			pdfPage.Graphics.DrawString($"GST NO: {mainLocation.GSTNo}", _normalFont, new PdfSolidBrush(_darkGray), new PointF(20, detailsRect.Y + 16)); // Further reduced spacing

		if (!string.IsNullOrEmpty(mainLocation.Address))
			pdfPage.Graphics.DrawString($"Address: {mainLocation.Address}", _normalFont, new PdfSolidBrush(_darkGray), new PointF(20, detailsRect.Y + 26)); // Further reduced spacing

		if (!string.IsNullOrEmpty(mainLocation.Email))
			pdfPage.Graphics.DrawString($"Email: {mainLocation.Email}", _normalFont, new PdfSolidBrush(_darkGray), new PointF(20, detailsRect.Y + 36)); // Further reduced spacing

		if (!string.IsNullOrEmpty(mainLocation.Phone))
			pdfPage.Graphics.DrawString($"Phone: {mainLocation.Phone}", _normalFont, new PdfSolidBrush(_darkGray), new PointF(20, detailsRect.Y + 46)); // Further reduced spacing

		var invoiceTitleSize = _headerFont.MeasureString(invoiceType);
		pdfPage.Graphics.DrawString(invoiceType, _headerFont, new PdfSolidBrush(_secondaryColor), new PointF(pdfPage.GetClientSize().Width - invoiceTitleSize.Width - 20, detailsRect.Y + 12)); // Moved up from Y + 24 to Y + 12

		return detailsRect.Height + detailsRect.Y + 15; // Reduced spacing
	}

	/// <summary>
	/// Creates and configures a PDF grid with common styling
	/// </summary>
	internal static PdfGrid CreateStyledGrid<T>(IEnumerable<T> dataSource, float[] columnWidths, PdfTextAlignment[] columnAlignments)
	{
		PdfGrid pdfGrid = new()
		{
			DataSource = dataSource.ToList()
		};

		// Set column widths
		for (int i = 0; i < columnWidths.Length && i < pdfGrid.Columns.Count; i++)
			pdfGrid.Columns[i].Width = columnWidths[i];

		// Apply header styling with adequate padding for readability
		pdfGrid.Headers.ApplyStyle(new PdfGridCellStyle
		{
			Font = _boldFont,
			TextBrush = PdfBrushes.White,
			CellPadding = new PdfPaddings(4, 3, 4, 3), // Increased to prevent text clipping
			BackgroundBrush = new PdfSolidBrush(_primaryColor),
			Borders = new PdfBorders { All = new PdfPen(Color.Black, 0.5f) }
		});

		// Set minimum height for header row
		if (pdfGrid.Headers.Count > 0)
			pdfGrid.Headers[0].Height = Math.Max(pdfGrid.Headers[0].Height, 20f);

		// Apply alternating row colors and ensure minimum row height
		int index = 0;
		foreach (var row in pdfGrid.Rows)
		{
			index++;
			if (index % 2 == 0)
				row.Style.BackgroundBrush = new PdfSolidBrush(_lightGray);
			else
				row.Style.BackgroundBrush = new PdfSolidBrush(Color.White);

			// Set minimum row height to prevent text clipping
			row.Height = Math.Max(row.Height, 18f); // Minimum height for readability
		}

		// Apply grid styling with adequate padding for readability
		pdfGrid.Style = new()
		{
			Font = _normalFont,
			TextBrush = PdfBrushes.Black,
			CellPadding = new PdfPaddings(4, 3, 4, 3), // Increased to prevent text clipping
		};

		// Set column alignments
		for (int i = 0; i < columnAlignments.Length && i < pdfGrid.Columns.Count; i++)
			pdfGrid.Columns[i].Format = new(columnAlignments[i], PdfVerticalAlignment.Middle);

		return pdfGrid;
	}

	/// <summary>
	/// Draws a summary section with financial totals - compact design with optimal space utilization
	/// </summary>
	internal static float DrawSummarySection(PdfDocument pdfDocument, PdfPage pdfPage, float currentY,
		Dictionary<string, string> summaryItems, decimal grandTotal, string additionalInfo = null)
	{
		// Calculate optimal layout based on number of items
		var items = summaryItems.Where(x => !string.IsNullOrEmpty(x.Value)).ToList();
		var itemCount = items.Count;
		
		if (itemCount == 0)
		{
			// If no items, just draw grand total and amount in words compactly
			return DrawCompactGrandTotalOnly(pdfPage, currentY, grandTotal, additionalInfo);
		}

		var pageWidth = pdfPage.GetClientSize().Width;
		var availableWidth = pageWidth - 30; // Total available width with margins

		// Smart column calculation for optimal space usage
		var columnsCount = itemCount <= 2 ? 1 : itemCount <= 6 ? 2 : 3;
		var rowsPerColumn = (int)Math.Ceiling((double)itemCount / columnsCount);
		
		// Calculate actual required width based on content
		var maxLabelWidth = 0f;
		var maxValueWidth = 0f;
		
		foreach (var item in items)
		{
			var labelWidth = _normalFont.MeasureString(item.Key).Width;
			var valueWidth = _boldFont.MeasureString(item.Value).Width;
			maxLabelWidth = Math.Max(maxLabelWidth, labelWidth);
			maxValueWidth = Math.Max(maxValueWidth, valueWidth);
		}
		
		// Minimum column width based on content + small padding
		var minColumnWidth = maxLabelWidth + maxValueWidth + 15f; // 15f padding between label and value
		var totalMinWidth = (minColumnWidth * columnsCount) + (columnsCount - 1) * 10f; // 10f gap between columns
		
		// Use minimum required width, but not less than 60% of available width for readability
		var summaryWidth = Math.Max(totalMinWidth + 20f, availableWidth * 0.6f); // 20f for margins
		var summaryX = (pageWidth - summaryWidth) / 2; // Center the summary section
		
		// Recalculate column width with actual summary width
		var columnGap = 10f;
		var columnWidth = (summaryWidth - 20f - (columnGap * (columnsCount - 1))) / columnsCount;

		// Calculate compact height
		var headerHeight = 18f; // Summary header
		var itemsHeight = rowsPerColumn * 12f; // Reduced from 14f to 12f for more compact rows
		var grandTotalHeight = 18f; // Grand total bar
		var amountWordsHeight = !string.IsNullOrEmpty(additionalInfo) ? 25f : 20f; // Amount in words
		var summaryHeight = headerHeight + itemsHeight + grandTotalHeight + amountWordsHeight + 12f; // Total with padding

		// Check if page has space for summary
		if (currentY + summaryHeight > pdfPage.GetClientSize().Height - _pageMargin)
		{
			pdfDocument.Pages.Add();
			pdfPage = pdfDocument.Pages[pdfDocument.Pages.Count - 1];
			currentY = _pageMargin;
		}

		var summaryRect = new RectangleF(summaryX, currentY, summaryWidth, summaryHeight);
		pdfPage.Graphics.DrawRectangle(new PdfPen(Color.Black, 1), new PdfSolidBrush(_lightGray), summaryRect);

		var summaryY = currentY + 6;
		pdfPage.Graphics.DrawString("Summary", _subHeaderFont, new PdfSolidBrush(_primaryColor), new PointF(summaryX + 8, summaryY));

		summaryY += 16; // Reduced spacing

		// Draw summary items in compact columns
		var currentColumn = 0;
		var currentRow = 0;
		var startY = summaryY;

		foreach (var item in items)
		{
			var columnX = summaryX + 8 + (currentColumn * (columnWidth + columnGap));
			var itemY = startY + (currentRow * 12f); // Compact row height

			DrawSummaryLine(pdfPage, item.Key, item.Value, columnWidth, columnX, itemY);

			currentRow++;
			if (currentRow >= rowsPerColumn)
			{
				currentRow = 0;
				currentColumn++;
			}
		}

		// Move Y position past the items with minimal spacing
		summaryY = startY + (rowsPerColumn * 12f) + 6f;

		// Draw grand total across full width
		var grandTotalRect = new RectangleF(summaryX + 4, summaryY, summaryWidth - 8, 18);
		pdfPage.Graphics.DrawRectangle(new PdfPen(_primaryColor, 2), new PdfSolidBrush(_primaryColor), grandTotalRect);
		pdfPage.Graphics.DrawString("Grand Total: ", new PdfStandardFont(PdfFontFamily.Helvetica, 8, PdfFontStyle.Bold),
			PdfBrushes.White, new PointF(summaryX + 8, summaryY + 1));

		var grandTotalText = grandTotal.FormatIndianCurrency();
		var grandTotalFont = new PdfStandardFont(PdfFontFamily.Helvetica, 8, PdfFontStyle.Bold);
		var grandTotalSize = grandTotalFont.MeasureString(grandTotalText);

		pdfPage.Graphics.DrawString(grandTotalText, grandTotalFont,
			PdfBrushes.White, new PointF(summaryX + summaryWidth - grandTotalSize.Width - 12, summaryY + 1));

		summaryY += 20;

		// Compact amount in words and payment mode layout
		var amountInWords = grandTotal.ToNumericWords();
		if (string.IsNullOrEmpty(amountInWords))
			amountInWords = "Zero";
		amountInWords += " Rupees Only";

		if (!string.IsNullOrEmpty(additionalInfo))
		{
			// Compact two-row layout instead of two columns for better space usage
			pdfPage.Graphics.DrawString($"Amount: {amountInWords}", _boldFont, new PdfSolidBrush(_primaryColor),
				new PointF(summaryX + 8, summaryY));
			
			summaryY += 12f;
			pdfPage.Graphics.DrawString($"Payment Mode: {additionalInfo}", _boldFont, new PdfSolidBrush(_secondaryColor),
				new PointF(summaryX + 8, summaryY));
		}
		else
		{
			pdfPage.Graphics.DrawString($"Amount: {amountInWords}", _boldFont, new PdfSolidBrush(_primaryColor),
				new PointF(summaryX + 8, summaryY));
		}

		return summaryRect.Y + summaryRect.Height + 8; // Reduced bottom margin
	}

	/// <summary>
	/// Draws a compact grand total section when there are no summary items
	/// </summary>
	private static float DrawCompactGrandTotalOnly(PdfPage pdfPage, float currentY, decimal grandTotal, string additionalInfo)
	{
		var pageWidth = pdfPage.GetClientSize().Width;
		var summaryWidth = pageWidth * 0.4f; // Even more compact when no items
		var summaryX = (pageWidth - summaryWidth) / 2;
		var summaryHeight = !string.IsNullOrEmpty(additionalInfo) ? 50f : 35f;

		var summaryRect = new RectangleF(summaryX, currentY, summaryWidth, summaryHeight);
		pdfPage.Graphics.DrawRectangle(new PdfPen(Color.Black, 1), new PdfSolidBrush(_lightGray), summaryRect);

		var summaryY = currentY + 6;
		
		// Grand total
		var grandTotalRect = new RectangleF(summaryX + 4, summaryY, summaryWidth - 8, 18);
		pdfPage.Graphics.DrawRectangle(new PdfPen(_primaryColor, 2), new PdfSolidBrush(_primaryColor), grandTotalRect);
		pdfPage.Graphics.DrawString("Grand Total: ", new PdfStandardFont(PdfFontFamily.Helvetica, 8, PdfFontStyle.Bold),
			PdfBrushes.White, new PointF(summaryX + 8, summaryY + 1));

		var grandTotalText = grandTotal.FormatIndianCurrency();
		var grandTotalFont = new PdfStandardFont(PdfFontFamily.Helvetica, 8, PdfFontStyle.Bold);
		var grandTotalSize = grandTotalFont.MeasureString(grandTotalText);

		pdfPage.Graphics.DrawString(grandTotalText, grandTotalFont,
			PdfBrushes.White, new PointF(summaryX + summaryWidth - grandTotalSize.Width - 12, summaryY + 1));

		summaryY += 22;

		// Amount in words
		var amountInWords = grandTotal.ToNumericWords();
		if (string.IsNullOrEmpty(amountInWords))
			amountInWords = "Zero";
		amountInWords += " Rupees Only";

		pdfPage.Graphics.DrawString($"Amount: {amountInWords}", _boldFont, new PdfSolidBrush(_primaryColor),
			new PointF(summaryX + 8, summaryY));

		if (!string.IsNullOrEmpty(additionalInfo))
		{
			summaryY += 12f;
			pdfPage.Graphics.DrawString($"Payment: {additionalInfo}", _boldFont, new PdfSolidBrush(_secondaryColor),
				new PointF(summaryX + 8, summaryY));
		}

		return summaryRect.Y + summaryRect.Height + 8;
	}

	/// <summary>
	/// Draws wrapped text within specified bounds
	/// </summary>
	internal static void DrawWrappedText(PdfPage pdfPage, string text, PdfFont font, PdfBrush brush,
		RectangleF bounds, PdfTextAlignment alignment, ref float currentY)
	{
		const float lineSpacing = 9f; // Reduced from 12f
		string[] words = text.Split(' ');
		string line = string.Empty;

		foreach (string word in words)
		{
			string testLine = string.IsNullOrEmpty(line) ? word : line + " " + word;
			SizeF testSize = font.MeasureString(testLine);

			if (testSize.Width <= bounds.Width)
				line = testLine;
			else
			{
				PdfStringFormat format = new() { Alignment = alignment };
				pdfPage.Graphics.DrawString(line, font, brush, new RectangleF(bounds.X, currentY, bounds.Width, bounds.Height), format);
				currentY += lineSpacing;
				line = word;
			}
		}

		if (!string.IsNullOrEmpty(line))
		{
			PdfStringFormat format = new() { Alignment = alignment };
			pdfPage.Graphics.DrawString(line, font, brush, new RectangleF(bounds.X, currentY, bounds.Width, bounds.Height), format);
			currentY += lineSpacing;
		}
	}

	/// <summary>
	/// Draws a summary line with label and value - optimized for column layout
	/// </summary>
	internal static void DrawSummaryLine(PdfPage pdfPage, string label, string value, float columnWidth, float columnX, float summaryY)
	{
		// Use smaller font for more compact display
		var labelFont = new PdfStandardFont(PdfFontFamily.Helvetica, 7); // Reduced from default for compact layout
		var valueFont = new PdfStandardFont(PdfFontFamily.Helvetica, 7, PdfFontStyle.Bold); // Reduced from default
		
		// Measure text to ensure proper alignment
		var labelSize = labelFont.MeasureString(label);
		var valueSize = valueFont.MeasureString(value);
		
		// Add colon for cleaner appearance if not present
		var displayLabel = label.EndsWith(":") ? label : label + ":";
		var availableWidth = columnWidth - 4f; // Small margin within column
		
		// Smart layout: if both fit comfortably, align value to right; otherwise use inline format
		if (labelSize.Width + valueSize.Width + 12f <= availableWidth) // 12f for comfortable spacing
		{
			// Draw label on the left
			pdfPage.Graphics.DrawString(displayLabel, labelFont, PdfBrushes.Black, new PointF(columnX, summaryY));
			
			// Draw value aligned to the right of the column
			var valueX = columnX + columnWidth - valueSize.Width - 2f;
			pdfPage.Graphics.DrawString(value, valueFont, new PdfSolidBrush(_secondaryColor), 
				new PointF(valueX, summaryY));
		}
		else
		{
			// Inline format for space efficiency: "Label: Value"
			pdfPage.Graphics.DrawString(displayLabel, labelFont, PdfBrushes.Black, new PointF(columnX, summaryY));
			
			var labelWidth = labelFont.MeasureString(displayLabel).Width;
			var remainingWidth = availableWidth - labelWidth - 2f; // 2f spacing
			
			// Check if value fits in remaining space
			if (valueSize.Width <= remainingWidth)
			{
				pdfPage.Graphics.DrawString(" " + value, valueFont, new PdfSolidBrush(_secondaryColor), 
					new PointF(columnX + labelWidth, summaryY));
			}
			else
			{
				// Truncate value if necessary
				var truncatedValue = value;
				while (valueFont.MeasureString(" " + truncatedValue + "...").Width > remainingWidth && truncatedValue.Length > 3)
				{
					truncatedValue = truncatedValue.Substring(0, truncatedValue.Length - 1);
				}
				
				var finalValue = truncatedValue == value ? " " + value : " " + truncatedValue + "...";
				pdfPage.Graphics.DrawString(finalValue, valueFont, new PdfSolidBrush(_secondaryColor), 
					new PointF(columnX + labelWidth, summaryY));
			}
		}
	}

	/// <summary>
	/// Draws invoice details section with left and right column layout
	/// </summary>
	internal static float DrawInvoiceDetailsSection(PdfPage pdfPage, float currentY, string sectionTitle,
		Dictionary<string, string> leftColumnDetails, Dictionary<string, string> rightColumnDetails)
	{
		var detailsRect = new RectangleF(15, currentY, pdfPage.GetClientSize().Width - 30, 60); // Further reduced from 75

		if (leftColumnDetails.Count > 3)
			detailsRect = new RectangleF(15, currentY, pdfPage.GetClientSize().Width - 30, 85); // Further reduced from 100

		pdfPage.Graphics.DrawRectangle(new PdfPen(Color.Black, 1), detailsRect);

		var leftX = 20; // Reduced from 30
		var rightX = pdfPage.GetClientSize().Width / 2 + 15; // Reduced from 20
		var detailY = currentY + 6; // Further reduced from 8

		// Section title
		pdfPage.Graphics.DrawString(sectionTitle, _subHeaderFont, new PdfSolidBrush(_primaryColor), new PointF(leftX, detailY));

		// Left column details with smaller spacing
		detailY += 16; // Further reduced from 20
		foreach (var detail in leftColumnDetails)
		{
			if (!string.IsNullOrEmpty(detail.Value))
			{
				pdfPage.Graphics.DrawString($"{detail.Key}: ", _normalFont, PdfBrushes.Black, new PointF(leftX, detailY));
				pdfPage.Graphics.DrawString(detail.Value, _boldFont, new PdfSolidBrush(_secondaryColor), new PointF(leftX + 45, detailY)); // Further reduced from 50
				detailY += 10; // Further reduced from 12
			}
		}

		// Right column details with smaller spacing
		detailY = currentY + 22; // Further reduced from 28
		foreach (var detail in rightColumnDetails)
			if (!string.IsNullOrEmpty(detail.Value))
			{
				pdfPage.Graphics.DrawString($"{detail.Key}: ", _normalFont, PdfBrushes.Black, new PointF(rightX, detailY));

				// Handle longer text for cash discount
				var valueWidth = detail.Key.Contains("Cash Discount") ? 75 : 45; // Further reduced from 85 and 50
				pdfPage.Graphics.DrawString(detail.Value, _boldFont, new PdfSolidBrush(_secondaryColor), new PointF(rightX + valueWidth, detailY));
				detailY += 10; // Further reduced from 12
			}

		return detailsRect.Height + detailsRect.Y + 15; // Reduced from 20
	}

	/// <summary>
	/// Creates a new PDF document with A4 size and templates
	/// </summary>
	internal static (PdfDocument document, PdfPage page) CreateA4Document()
	{
		var pdfDocument = new PdfDocument();
		var pdfPage = pdfDocument.Pages.Add();
		pdfDocument.PageSettings.Size = PdfPageSize.A4;

		pdfDocument.Template.Top = CreateHeader(pdfDocument, "PRIME BAKES");
		pdfDocument.Template.Bottom = CreateFooter(pdfDocument);

		return (pdfDocument, pdfPage);
	}

	/// <summary>
	/// Finalizes PDF document and returns as MemoryStream
	/// </summary>
	internal static MemoryStream FinalizePdfDocument(PdfDocument pdfDocument)
	{
		var stream = new MemoryStream();
		pdfDocument.Save(stream);
		pdfDocument.Close();
		return stream;
	}
}